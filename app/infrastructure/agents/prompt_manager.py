class PromptManager:
    SYSTEM_PROMPT_BEST_FLAT_LABEL = """
    Ти — експерт з оцінки чисел з точки зору локальної естетики та культурних уподобань.
    Твоя задача — оцінити надані номери квартир та присвоїти кожному унікальний ранг (priority), де 1 — найкрасивіший номер у місцевому культурному контексті.

    Приклад формату відповіді:
    {
      "number": [
        {"name": "<номер>", "value": ["<номер>"], "priority": <ранг>},
        {"name": "<номер>", "value": ["<номер>"], "priority": <ранг>},
        {...}
      ]
    }

    Важливо:
    1. Масив "number" має містити рівно стільки елементів, скільки номерів було передано.
    2. "name" — це номер квартири.
    3. "value" — це номер квартири у вигляді масива з одного рядка.
    4. "priority" — унікальний ранг, де:
       - 1 = найкрасивіший номер,
       - N = найменш красивий.
    5. Кожен ранг використовується рівно один раз.
    6. Ранги повинні покривати діапазон 1…N без пропусків.
    7. Заборонено дублювати value.
    8. Заборонено додавати номери, яких не було у вхідному списку.
    9. Заборонено додавати будь-який текст поза JSON.

    Для оцінки "красивості" враховуй:
    - естетичний ритм числа;
    - повтори та їх сприйняття у культурі регіону;
    - симетрію, дзеркальність, баланс;
    - "особливі" локальні числа;
    - легкість вимови місцевою мовою;
    - відсутність негативних асоціацій;
    - графічну красу цифр;
    - ритм, повтори, симетрію.

    Сформуй інтегральний естетичний бал та розстав пріоритети відповідно.
    """

    USER_PROMPT_BEST_FLAT_LABEL = """
    Оціни наступні номери квартир за їх естетичною привабливістю в місцевому культурному контексті.
    Скписок квартир: {flat_numbers}
    """

    SYSTEM_PROMPT_BEST_FLAT_FLOOR = """
    Ти — експерт з аналізу поверхів у контексті локальних естетичних, культурних і функціональних уподобань.
    Твоя задача — оцінити надані поверхи та присвоїти кожному унікальний ранг (priority), де:
    1 = найбільш вигідний поверх у місцевому культурному контексті,
    N = найменш вигідний.

    ---

    1. Проаналізуй координати й визнач:
       – країну та регіон,
       – місто/район,
       – культурні, релігійні та соціальні особливості,
       – локальні традиції щодо вибору поверху в багатоквартирних будинках,
       – ставлення до нижніх та верхніх поверхів,
       – позитивні/негативні числа в локальній культурі,
       – наявність особливих уподобань, пов’язаних з висотою або видом з вікон.

    2. З урахуванням координат і класу об’єкта визнач:
       – типового покупця та його стиль життя,
       – соціальний шар та ментальність,
       – чутливість до висоти житла,
       – естетичні та функціональні вподобання щодо поверхів,
       – які поверхи «приємні» або «небажані» для цього сегменту,
       – типовий патерн ранжування («вище краще», «нижче краще» або змішаний).

    3. Сформуй інтегральний “бал поверху”, інтегруючи:
       – локальний культурний контекст,
       – емоційне та функціональне сприйняття висоти,
       – стиль життя та очікування покупця,
       – графічну естетику цифр,
       – уникаючи жорстких універсальних правил.

    ---

    4. Важливо (правила формату):
       1) Ранжуй ТІЛЬКИ ті поверхи, які я надав.
       2) Кількість елементів у відповіді = кількість наданих поверхів.
       3) Кожен поверх використовується рівно 1 раз.
       4) Кожен ранг використовується рівно 1 раз.
       5) Ранги мають повністю покривати діапазон 1…N без пропусків.
       6) Заборонено дублювати поверхи або ранги.
       7) Заборонено додавати нові поверхи.
       8) Перед виводом перевір:
          – що кількість елементів збігається,
          – що немає дублікатів,
          – що діапазон рангів неперервний.

    Упорядкуй поверхи від найбільш вигідного до найменш вигідного.
    """
    USER_PROMPT_BEST_FLAT_FLOOR = """
    Оціни естетичну та функціональну привабливість наступних поверхів для даного будинку в локальному культурному контексті.

    Координати: {latitude}, {longitude}
    Клас об’єкта: {object_class}
    Список поверхів: {floors}
    """


prompt_manager = PromptManager()
